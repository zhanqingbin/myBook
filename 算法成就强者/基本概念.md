# 算法基本概念

### 数据结构：数据存储的形式，决定了使用数据时是否方便

- 时间复杂度：算法需要多少时间
- 空间复杂度：占多大内存
- 大 O 表示法：程序需要进行多少次，来衡量算法的复杂度
- 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

  ```js
  // O(n)：无序数组 findIndex()
  let arr = [12, 6, 8, 34, 2, 12, 31];
  function find(arr: number[], val: number) {
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] == val) return i;
    }
    return -1;
  }
  console.log(find(arr, 12)); //1
  console.log(find(arr, 54)); //n
  ```

- 无序数组（日志）：增：O(1)， 删 O(n)后边要往前移， 改：O(1)，查：O(n)
- 有序数组（一二）：增：O(n)维持有序要往前提， 删 O(n)， 改：O(n)，查：O(log(n))

### 数学

- 常数 O(1)：直线 最优
- 对数 O(log(n))：小坡最后趋近常数 第二优
- 线性 O(n)：斜线 凑合
- 指数 O(n^2)：陡坡最后接近无穷大
- 级数 O(2^n)：最恶心 10-20 个数据上限 旅行社问题
- P 问题：在确定性计算设备上，可在多项式时间内求解的问题：常数，对数，线性，指数
- NP 问题：在确定性计算设备上，以多项式时间验证答案准确性的问题/量子计算机能算的
  无解问题

### 思想

分治法：将问题分为更小的单位，直到问题的规模可以求解，然后将结果合并

```js
// 有序数组二分搜索：log2(n)
function findInOrderedArr(arr: number[], val: number) {
  let s = 0; // 起始点
  let e = arr.length - 1; // 中止点
  // 起点<=终点
  while (s <= e) {
    let center = Math.floor((s + e) / 2);
    if (arr[center] == val) {
      return center; // 中间的值就是要找的
    } else if (arr[center] > val) {
      e = center - 1; // 右边废了——往左边找
    } else {
      s = center + 1; // 左边废了——往右边找
    }
  }
  return -1;
}
```

递归：有一部分语言，函数是可重入的，函数没执行完之前，可以再次被调用

- 最经典：斐波那契数列：1 1 2 3 5 8 13 21 34 f(1)=1 fn(2)=2 f(n)=f(n-1)+f(n-2)

  ```js
  function f(n: number): number {
    if (n == 1) {
      return 1;
    } else if (n == 2) {
      return 1;
    } else {
      return f(n - 1) + f(n - 2);
    }
  }
  console.log(f(10)); //55

              f(5)
       f(4)    +    f(3)
    f(3) + f(2) + f(2)+f(1)
  f(2)+f(1)  1     1     1
  ```

- 二分搜索递归：
  ```js
  function find(arr: number[], val: number, s: number, e: number): number {
    if (s > e) return -1;
    let center = Math.floor((s + e) / 2);
    if (arr[center] == val) {
      return center; // 找到了直接返回
    } else if (arr[center] > val) {
      return find(arr, val, s, center - 1); // 找左边
    } else {
      return find(arr, val, center + 1, e); // 找右边
    }
  }
  ```

### 数据结构

- 线性表（数组）：一块连续的线性空间，访问线性任何数据 O(1)，总长度是固定的，不够重新分配，复制已有的数据，释放原来的数据。分多了浪费
- 链表：不连续的空间组成的，优点：不够可以加，不会浪费。访问某个位置 O(n)

  | 方法 | 线性表-无序表 | 线性表-有序表  | 普通链表 | 头尾链表/双链表  |
  | ---- | ------------- | -------------- | -------- | ---------------- |
  | 获取 | 1             | 1              | n        | -                |
  | 设置 | 1             | n              | n        | -                |
  | 插入 | n             | n              | n        | -                |
  | 追加 | n             | n              | n        | 1                |
  | 删除 | n             | n              | n        | 1                |
  | 搜索 | n             | log(n)         | n        | -                |
  | 结论 | 无需搜索      | 频繁、大量搜索 | 毫无用处 | 从头尾删除、添加 |

  循环链表：头尾相连

  缓存链表：记录遍历的位置

- 队列（queue）：排队，先进先出，后进后出。如：下载队列、客服队列 数组入队等

- 堆栈（stack）：像堆盘子，先进后出 浏览器历史记录，回退、ctrl+z、函数

  | 方法 | 线性表-堆栈 | 链表-堆栈 |
  | ---- | ----------- | --------- |
  | 入栈 | n           | 1         |
  | 出栈 | n           | 1         |
  | 总结 | 不好        | 优秀      |

  | 方法 | 线性表-队列 | 链表-队列 |
  | ---- | ----------- | --------- |
  | 入队 | n           | 1         |
  | 出队 | n           | 1         |
  | 结论 | 不好        | 优秀      |

- 树：树——html 就是树，数据明显层次适合用树

  | 方法 | 方式             | 复杂度 |
  | ---- | ---------------- | ------ |
  | 添加 | 查找+appendChild | O(n)   |
  | 删除 | 查找+removeChild | O(n)   |
  | 查找 |                  | O(n)   |
  | 修改 | 查找+修改        | O(n)   |

  结论：普通树性能并不高，重点在于按照层级关系来存储数据（层级 户籍 银行账户）

- 二叉树：每个节点最多有两个子节点
- 二叉查找树：它是一棵二叉树，左子树中所有的节点都比根节点小，右子树所有的节点都比根节点大

  二叉查找树——查找速度：log(n)

  | 方法 | 有序数组 | 二叉树 |
  | ---- | -------- | ------ |
  | 查找 | log(n)   | log(n) |
  | 添加 | n        | log(n) |
  | 修改 | n        | log(n) |
  | 删除 | n        | log(n) |

  应用：磁盘；标识符：身份证号、银行卡号、商品 ID

- 遍历树：
  - 深度优先：探索左边一直到底：解可能在深处
  - 广度优先：地毯式一层一层搜索：解可能在浅处
- 二叉树遍历：
  - 前序 当前, left, right 1, 2, 4, 5, 6, 7, 3
  - 中序 left, 当前, right 4, 2, 6, 5, 7, 1, 3
  - 后序 left, right, 当前 4, 6, 7, 5, 2, 3, 1
    ```js
         1
        2  3
      4  5
        6  7
    ```
- 二叉排序：
  - 1.把数据随意插入 BST
  - 2.按照“中序遍历”的顺序，把数据重新遍历出来

| 方法     | 线性表    | 链表       | 堆栈 | 队列 | 广义树 | BST    |
| -------- | --------- | ---------- | ---- | ---- | ------ | ------ |
| 增       | n         | 1          | 1    | 1    | n      | log(n) |
| 删       | n         | n          | 1    | 1    | n      | log(n) |
| 改       | 1/n       | n          | -    | -    | n      | log(n) |
| 查       | log(n)/n  | n          | -    | -    | n      | log(n) |
| 排序     | n\*log(n) | n^2        | -    | -    | -      | 0      |
| 适用场景 | 定长      | 长度不固定 | 特化 | 特化 | 有层级 | 搜索   |
